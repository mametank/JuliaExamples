PerlとJuliaの比較
================

PerlからJuliaに移行する場合の留意点を簡単にまとめる。

プログラム全般
------------

### スクリプトファイル

- Perlは拡張子として `.pl` を、Juliaは拡張子として `.jl` を使用する。
- どちらの言語も、コメントに `#` が利用できる。
- Juliaでは、スクリプトファイルはUnicodeで記述することが前提である。
- コマンドラインからスクリプトを実行するには、Perlなら `perl script.pl` であり、Juliaなら `julia script.jl` となる。

### プログラム

- Perlは文の末尾にセミコロンが必要である。Juliaは不要であるが、1行に複数のコマンドを並べる場合には必要である。なお、これ以降のPerlのプログラム例では、とくに必要な場合を除いてセミコロンをつけていない。
- Perlの `use strict` に相当する仕組みが、Julia（v0.6）には存在しない。
- Perlの変数には型がないが、Juliaの変数には型が存在し、これを生かすかどうかがパフォーマンスを左右する。詳しくは後述する。
- 変数のスコープは、両言語でほぼ同じである。Perlでは `{...}` が、Juliaでは `ブロック開始キーワード ... end` がスコープ範囲である。ただしJuliaでは `if ... end` と `begin ... end` ブロックは、変数のスコープとしては機能しない。
- Juliaでは関数外の処理は、動作はするが、最適化がなされないために遅い。パフォーマンスを高めるためには、すべての処理を関数に含めることが推奨される。つまり、メイン処理のための関数を作る必要がある。

### 用語の対比

|Perl|Julia|
|:---|:---|
|ハッシュ|辞書|
|サブルーチン|関数|
|モジュール|パッケージ|


制御構文
--------

### 条件文

|処理|Perl|Julia|
|:---|:---|:----|
|回数指定ループ|`if(条件){ ... } elsif(条件){ ... } else{ ... }`|`if 条件 ... elseif 条件 ... else ... end`|

どちらも改行なしで書くことができる。

```perl
perl) if($a<10){
         ...
      }
      elsif($a>20){
         ...
      }
      else{
         ...
      }
```
```julia
julia) if a<10
          ...
       elseif a>20
          ...
       else
          ...
       end
```

### 回数指定のループ

|処理|Perl|Julia|
|:---|:---|:----|
|回数指定ループ|`for(初期化;条件;カウントアップ){ ... }`|`for 範囲指定 ... end`|

どちらも改行なしで書くことができる。

```perl
perl) # 10回のループ
perl) for($i=0;i<10;i++){
         ...
      }
```
```julia
julia) # 10回のループ
julia) for i=1:10
         ...
       end
```

### 繰り返し処理

どちらの言語でも、配列の要素やハッシュキーの取り出しなどの繰り返し処理ができる。

|処理|Perl|Julia|
|:---|:---|:----|
|反復処理|`foreach 変数 (集合){ ... }`|`for 変数 in 集合 ... end`|

どちらも改行なしで書くことができる。

```perl
perl) foreach i (@array){
         ...
      }
```
```julia
julia) for i in array
         ...
       end
```

### 条件付き反復

|処理|Perl|Julia|
|:---|:---|:----|
|条件付き反復|`while(条件){ ... }`|`while 条件 ... end`|

どちらも改行なしで書くことができる。

```perl
perl) while($i>0){
         ...
      }
```
```julia
julia) while i>0
         ...
       end
```

### ループ制御

|処理|Perl|Julia|
|:---|:---|:----|
|ループの脱出|`last`|`break`|
|現在の処理をスキップ|`next`|`continue`|


スカラと型
---------

### スカラと型

スカラ（scalar）は単一の数量・データである。
両方の言語で、整数、浮動小数点数、文字列などはスカラとして扱われる。
ただし、Perlは型の概念が曖昧（もしくは無い）のに対し、Juliaには厳密な型の概念がある。

たとえば、Perlでは数値は整数と浮動小数点数の区別はないが、Juliaは両者を区別する。
また、Perlは文脈に応じて文字列を数値として解釈する（その逆もある）が、Juliaは指示しない限り型変換が行われることはない（文字列を数値として扱うとエラーになる）。

リテラル（ソースコードに記入する生のデータ）は、両言語でほぼ同じである。
いかに例を示す。

|処理|Perl|Julia|
|:---|:---|:----|
|整数|`10`, `123`, `1_000_000`（百万）|`10`,`123`,`1_000_000`（百万）|
|浮動小数点数|`1.0`,`3.14`,`1e-3`|`1.0`,`3.14`,`1e-3`|
|文字列|"abc"|"abc"|

### 型変換

Perlには型の概念がない。
Juliaで型変換するには、関数を使う必要がある。
型変換に関しては、以下の変数の項目および文字列の項目でより詳しく説明する。

```julia
julia) # 数値を文字列に変換
julia) string(10)

julia) # 文字列を整数に変換
julia) parse(Int,"12345")
julia) # 文字列を浮動小数点数に変換
julia) parse(Float64,"12345")
```

データ構造と変数
-------------

### 変数名

PerlもJuliaも宣言なしで変数を利用できる。
どちらの言語にも大文字と小文字の区別がある。
Perlでは変数名に接頭辞（たとえば `$`）をつける必要があるが、Juliaでは必要ない。

```perl
perl) $a = 10
```
```julia
julia) a = 10
```

### スコープ

PerlもJuliaも、スコープ内で定義された変数は、そのスコープ内でのみ有効である。
Perlは `{ ... }` で囲まれた範囲が、Juliaはブロック（`for ... end` や `do ... end` など）がスコープとなる。
ただしJuliaでは `if ... end` と `begin ... end` ブロックは、変数のスコープとしては機能しない（つまり、この2つに関しては、ブロック内で宣言された変数が、ブロック外でも参照可能になる）。

また、Juliaでは `global` によりグローバル変数が定義できるが、推奨されていない。

### スカラ変数

#### 変数と型

Perlではスカラ変数には接頭辞 `$` を付加する（`$変数名`）が、Juliaには接頭辞は必要ない。
Perlは、スカラ変数には整数、浮動小数点数、文字列などを区別することなく代入できる。
Juliaにも、どんな値も保持できる万能型（Any）が存在するが、速度の問題から、これは推奨されていない。

Juliaでは変数に型があり、変数がその型のデータのみを扱うときに限り、非常に高速に動作する。
代表的なスカラ型として、整数（`Int`）、浮動小数点数（たとえば`Float64`）、文字列（`String`）がある。
とくに宣言が無い場合、その変数が最初に作られるときに、変数の型が確定する。
Juliaは、変数の作成と代入の手順を追うことで、たとえ型の宣言がなくても、変数型を正確に推定できる。

#### 型変換

Perlでも明示的に型を変換することはできる。
Juliaには型変換を行う関数が用意されている。

|処理|Perl|Julia|
|:---|:---|:----|
|数値を文字列に変換|`$x.""` または `"$x"`|`string(x)`|
|文字列を数値に変換|`$x+0`|`parse(型,x)`|

文字列から数値への変換には、型の指定が必須である。
以下の例を参照のこと。

```julia
julia) # 文字列を整数に変換
julia) parse(Int,x)

julia) # 文字列を浮動小数点数に変換
julia) parse(Float64,x)
```

数値から文字列への変換には、このほかにも多くの方法がある。
詳しくは後述の文字列の項目で紹介する。

### 配列

Perlでは変数名の接頭辞として `@` を使うが、Juliaでは接頭辞は必要ない。
Juliaでは、配列の要素にも型があるため、最初に定義した型以外のデータを使うことのないように配慮すべきである。

#### 配列の作成

以下の例を参照のこと。

```perl
perl) @a = (1,2,3,4,5)
```
```julia
julia) a = [1,2,3,4,5]
```

#### 配列の参照

| |Perl|Julia|
|:---|:---|:----|
|要素の参照|`$変数名[]`|`変数名[]`|
|添え字の開始位置|`0`|`1`|
|添え字の最終位置|`-1`または`$#変数名`|`end`|

```perl
perl) # 3 は 4 番目の要素
parl) $a[3]
```
```julia
julia) # 3 は 3 番目の要素
julia) a[3]
```

最後の要素を参照するには、Perlでは`-1`または`$#配列名`を、Juliaでは`end`を用いる。

```perl
perl) # 最後の要素
parl) $a[-1]
perl) $a[$#a]
```
```julia
julia) # 最後の要素
julia) a[end]
```

#### 配列への要素の代入、および配列の確保

Perlでは、配列が存在しない状況でも、任意の要素位置に代入できる。
Juliaでは、存在しない配列への要素の代入はできない。

```perl
perl) # 存在しない配列の要素に代入
parl) $x[4] = 1
```
```julia
julia) # 存在しない配列への代入はエラーになる
julia) x[4] = 1
```

Juliaで配列の添え字を使うためには、その配列の型とサイズを事前に確定される必要がある。
配列を確保するには、`Array`または`Vector`キーワードを以下のように用いる。
配列を確保した上でゼロで初期化するには、`zeros()`関数を利用するか、`[]`と反復処理を組み合わせる。

```julia
julia) # 5個の要素を持つ整数型の配列を宣言する
julia) # 以下の2つとも同じ結果になる
julia) x = Vector{Int}(5)
julia) x = Array{Int,1}(5)

julia) # 配列を確保し、ゼロで初期化する
julia) # 以下の2つとも同じ結果になる
julia) x = zeros(Int,5)
julia) x = [0 for i=1:5]
```

Juliaで文字列型の配列を初期化するには、以下のようにする。

```julia
julia) # 配列を確保するが内容は初期化しない
julia) y = Array{String,1}(5)

julia) # 配列を確保して、空文字列で初期化する
julia) y = ["" for i=1:5]
```

#### pushとpop

Juliaは、配列を全く確保していなくても、pushやunshift処理を行うことができる。

| |Perl|Julia|
|:---|:---|:----|
|末尾に要素を追加|`push @変数名,値`|`push!(変数名,値)`|
|末尾の要素を除去|`pop @変数名`|`pop!(変数名)`|
|先頭に要素を追加|`unshift @変数名,値`|`unshift!(変数名,値)`|
|先頭の要素を除去|`shift @変数名`|`shift!(変数名)`|

#### 配列の範囲の参照

Perlでは、配列の一部をスライスと呼ぶ。

| |Perl|Julia|
|:---|:---|:----|
|範囲を指定する添え字|`[開始位置..終了位置]`|`[開始位置:終了位置]`|
|配列の最後の位置|`$#配列名`|`end`|

```perl
perl) # 末尾の3個の要素
perl) @a[2..4]
```
```julia
julia) # 末尾の3個の要素
julia) a[3:5]
```

最後の位置をキーワードで指定する。

```perl
perl) # 末尾の3個の要素
perl) @a[2..$#a]
```
```julia
julia) # 末尾の3個の要素
julia) a[3:end]
```

#### 配列の配列（二次元配列）

Perlの配列は一次元であり、二次元配列を擬似的に実現するには、配列の配列を使う必要がある。
Juliaでは二次元配列が定義できるだけでなく、配列の配列も定義できる。
Juliaの二次元配列は、一次元配列とは明確に区別されている（たとえば要素の区切りにカンマではなくスペースを使用する）。

```perl
perl) # 配列の配列で行列を実現する；2行3列目の要素を抜き出す
perl) @a = ([1,2,3],[4,5,6])
perl) $a[1][2]
```
```julia
julia) # 行列を定義し、2行3列目の要素を抜き出す
julia) # 要素の区切りにはスペースを使う；カンマで区切るとエラーになる
julia) a = [1 2 3; 4 5 6]
julia) a[2,3]
```

以下の例は、Juliaで配列の配列を定義するものである。

```julia
julia) a = [[1,2,3],[4,5,6]]
julia) a[2][3]
```

### ハッシュ（辞書）

#### ハッシュの作成

連想配列は、Perlではハッシュ、Juliaでは辞書と呼ばれる。
PerlもJuliaも、キーと値の両方にどのような型を使ってもよい。
ただしJuliaでは、キーと値の型を事前に定義しておく必要がある。
Perlのハッシュ変数には接頭辞 `%` を付加するが、Juliaでは接頭辞は必要ない。

```perl
perl) # 1行目のハッシュの初期化は実際には不要
perl) %hash = ()
perl) $hash{"abc"} = 1
```
```julia
julia) # ハッシュの初期化が必要（キーは文字列、値は整数）
julia) hash = Dict{String,Int}()
julia) hash["abc"] = 1
```

以下の例ではハッシュに配列を格納している（配列のハッシュ）。
Juliaは、配列の型を事前に決める必要がある。

```perl
perl) # 1行目のハッシュの初期化は実際には不要
perl) %hash = ()
perl) $hash{"abc"} = ([1,2,3])
```
```julia
julia) # ハッシュの初期化が必要（キーは文字列、値は整数）
julia) hash = Dict{String,Vector{Int}}()
julia) hash["abc"] = [1,2,3]
```

#### キーと値の取り出し

ハッシュ内に存在しないキーを指定した場合、Perlでは暗黙の空白（数値ではゼロ）を返すが、Juliaではエラーになる。
そのため、Juliaでは、キーに対応したエントリが存在するかどうかを確認する必要がある。
また、どちらの言語にも、キーと値を取り出す関数がある。

| |Perl|Julia|
|:---|:---|:----|
|要素の存在を確認|`exists 要素`|`haskey(辞書,キー)`|
|キーの集合を抜き出す|`keys ハッシュ`|`keys(辞書)`|
|値の集合を抜き出す|`values ハッシュ`|`values(辞書)`|
|キーと値のペアを抜き出す|`each`|以下の例を参照|

エントリの存在を確認するプログラム例を示す。

```perl
perl) if(exists $hash{"abc"}){ ... }
```
```julia
julia) if haskey(hash,"abc") ... end
```

以下の例は、存在するキーを取り出して順次処理する典型的なプログラムである。

```perl
perl) foreach $key (keys %hash){
         ...
      }
```
```julia
julia) for key in keys(hash)
          ...
       end
```

以下の例は、キーと値のペアを順次取り出すプログラムである。

```perl
perl) while (($key,$value) = each %hash){
         ...
      }
```
```julia
julia) for (key,value) in hash
          ...
       end
```

#### エントリの削除とハッシュの初期化

| |Perl|Julia|
|:---|:---|:----|
|エントリの削除|`delete 要素`|`delete(辞書名,キー)`|
|ハッシュの初期化|`%変数=()`|`変数=Dict{キー型,値型}()`|


データの更新（上書き）
------------------

### （イ）ミュータブルなデータ

Juliaでは、作成するデータに「変更可能（ミュータブル）」か「変更不可（イミュータブル）」かの区別がある。
変更可能なデータの代表例が配列と辞書であり、変更不可のデータには数値と文字列が含まれる。
この属性は、変数にも引き継がれる。

たとえば、以下のプログラムでは、文字列の一部を変更しようとしている、エラーが出て停止してしまう。
これは、Juliaでは文字列は変更不可であり、どうしても変更したいなら新しい文字データを作り直す必要がある（そしてそれが推奨されている）ためだ。

```julia
julia) 文字列の一部を書き換えようとするとエラーになる
julia) str = "abcdefg"
julia) str[3:5] = "345"
```

単一の数値を含む変数は、一見して変更が可能なように見える。
しかし、これは新たに変数を定義し直しているのであって、もとの変数の値が更新されているのではない。

```julia
julia) x = 1
julia) x = 5   # これは新しい変数 x を定義し直しているだけである
```

### リファレンスとコピー

Juliaには、変数の代入に関して、いくつか不思議に見える挙動があるが、これもデータの変更可能性に関係している。
これは、配列を参照する変数（以下の例）で顕著である。

```julia
julia) a = [1,2,3]  # 配列を作る
julia) b = a        # bはaを参照する
julia) b[1] = 0     # bを変更する
julia) println(a)   # 元の配列を表示
[0, 2, 3]           # bを変更すると、aも変更された！
```

これは数値では起こらない。
たとえば `a=10; b=a; b=0` としても、`a`は10のままである。
これは、Juliaでは、数値や文字列はイミュータブル（変更不可）で値渡し、配列や辞書はミュータブル（変更可能）で参照渡しであることに由来する（注：Juliaではあらゆる演算子が関数として機能する）。

つまり、Juliaでは、ある変数が配列や辞書（ミュータブル）である場合、それを参照する変数はリファレンス（ポインタ）であって、元のデータのコピーを持つわけではない。
もし、リファレンスではなく、元の実体のコピーを作りたいなら、`copy()` 関数を用いる。

```julia
julia) a = [1,2,3]  # 配列を作る
julia) b = copy(a)  # bはaのコピーを持つ
julia) b[1] = 0     # bを変更する
julia) println(a)   # 元の配列を表示
[1, 2, 3]           # aとbは別物なので、値は変更されていない
```

この挙動は、サブルーチン（関数）の設計に影響する。


文字列の処理
----------

### 基本の処理

#### 文字列処理関数

正規表現を使わない、基本の文字列処理の方法を示す。
後述する正規表現を使えば、ここで示した方法を置き換えることができるかもしれない。
以下のJulia関数について、オプション引数は省略した。
詳しくはJulia言語のマニュアルを参照のこと。

| |Perl|Julia|
|:---|:---|:----|
|文字列の定義|`"..."` または `'...'`|`"..."`|
|文字列の連結|`文字列 . 文字列`|`文字列 * 文字列`|
|文字列の長さ|`length(文字列)`|`length(文字列)`|
|文字列の繰り返し|`文字列 x 回数`|`文字列 ^ 回数`|
|文字列の切り出し|`substr(文字列,開始位置,文字数)`|`文字列[開始位置:終了位置]`（配列と同じ）|
|文字列の入れ替え|`substr(文字列,開始位置,文字数,置換文字列)`|対応する関数なし|
|文字列の分割|`split(/正規表現/,文字列)`|`split(文字列,区切り文字)`|
|文字列配列の結合|`join(配列,区切り文字)`|`join(配列,区切り文字)`|
|検索（文字列の有無）|`~/正規表現/`|`contains(対象文字列,検索文字列)`|
|検索（文字列の位置）|`index(対象文字列,検索文字列)`|`search(対象文字列,検索文字列)`|
|置換|`文字列 =~ s/検索文字列/置換文字列/g`|`replace(検索文字列,検索文字列,置換文字列)`|

#### 文字列の入れ替え

Juliaには、標準では、特定の位置の文字列を入れ替える（上書きする）関数が存在しない（特定の文字列を検索して置換する機能はある）。
これはJuliaでは、一度作成した文字列は変更不可（イミュータブル）だからだ。
Juliaでこれを実現するには、特定位置の文字列を入れ替えた、新しい文字列を定義すればよい。

```julia
julia) # 文字列の3文字めから5文字めを入れ替える
julia) str = "abcdefg"
julia) str = str[1:2] * "345" * str[6:end]
```
その他のアプローチとして、後述する正規表現と `replace()` 関数を組み合わせる、文字列を文字配列に分解して置換するなどがある。

```julia
julia) str = "abcdefg"

# 以下のいずれも同じ結果になる
julia) replace(str,r"(?<=.{2}).{3}(?=.*)","345")
julia) replace(str,r"(?<head>.{2})(.{3})(?<tail>.*)",s"\g<head>345\g<tail>")
julia) x=collect(str); x[3:5]=collect("345"); join(x)
```

#### 文字列への変換・文字列からの変換

変数の項目ですでに説明したが、文字列型から他の型への変換方法、および他の型から文字列型への変換方法は以下の通りである（再掲）。

|処理|Perl|Julia|
|:---|:---|:----|
|数値を文字列に変換|`$x.""` または `"$x"`|`string(x)`|
|文字列を数値に変換|`$x+0`|`parse(型,x)`|

数値を文字列に変換するとき、どちらの言語でもいわゆる `sprintf` が利用可能である。
ただし Julia では、これはマクロ（先頭に`@`がつく式）で実装されている。

```perl
perl) $str = sprintf("%6.3f",3.1415926)
```
```julia
julia) str = @sprintf("%6.3f",3.1415926)
```

#### 文字列内での変数と特殊記号の展開

両方の言語で、文字列内で変数を展開できる。
Juliaでは変数だけでなく、`@sprintf`も利用可能である。

|処理|Perl|Julia|
|:---|:---|:----|
|文字列内で変数を展開|`"$変数名"` または `"${変数名}"`|`"$(変数名)"`|

いくつかの特殊記号は文字列中で特別な意味を持つ。
ごく一部を以下に示す。

||Perl|Julia|
|:---|:---|:----|
|改行|`\n`|`\n`|
|タブ|`\t`|`\t`|
|ドル記号そのもの|`\$`|`\$`|
|バックスラッシュ|`\\`|`\\`|
|ダブルクオーテーション|`\"`|`\"`|

以下に変数展開の例を示す。

```perl
perl) $x = 3.1415926
perl) print "Pi is $(x).\n"
```
```julia
julia) x = 3.1415926
julia) print("Pi is $(x).\n")

julia) print("Pi is $(@sprintf("%.2f",x)).\n")
```

#### 文字列の分割と結合

文字列の分割と結合には、以下の関数が利用できる。

||Perl|Julia|
|:---|:---|:----|
|文字列の分割|`@配列 = split(/正規表現/,文字列)`|`配列 = split(文字列,区切り文字列, ...)`|
|文字列配列の結合|`文字列 = join(@配列,区切り文字列)`|`文字列 = join(配列,区切り文字列)`|

Juliaの `split` で、区切り文字を省略できる。
この場合、文字列の先頭および末尾のスペースを無視した上で、1つ以上のスペースを区切りとして、文字列を分割する（awkのフィールド分割と同じである）。
また、区切り文字には正規表現が利用できる。

以下に典型的な文字分割の例を示す。

```perl
perl) @array = split(/ */,$str)
```
```julia
julia) array = split($str)
```

Juliaでは、上の処理は以下の命令文と同じである。

```julia
julia) array = split($str," ",keep=false)
```

ここで区切り文字として、単一のスペース（`" "`）を指定している。
第3引数がなければ、このままでは、連続するスペースがすべて要素として分割されてしまい、しかも先頭と末尾の連続するスペースも除去されずに分割されてしまう。
そして、連続するスペースは、すべて空っぽの要素として配列に含まれてしまう。
この第3引数の `keep=false` は、空っぽの要素を捨てるオプションであり、このおかげで連続スペースの問題をクリアしている。


### 正規表現

Juliaは、Perl相当の正規表現を処理でき、検索と置換に関する関数が用意されている。
Perlの正規表現はそれ単体のオブジェクトだが、Juliaでは特殊な文字列 `r"正規表現"` を用いて指定する（文字列に `r` がついている）。
Juliaでは、上に示した検索・置換のそれぞれの関数は、正規表現にも対応している。
PerlとJuliaの機能は、以下のように対応できる。

| |Perl|Julia|
|:---|:---|:----|
|マッチング|`文字列 =~ /正規表現/`|`ismatch(正規表現,文字列)`|
|検索|`検索文字列 ~ /検索パターン/`|`search(検索文字列,検索パターン)`|
|置換|`検索文字列 =~ s/検索パターン/置換パターン/g`|`replace(検索文字列,検索パターン,置換パターン)`|

#### 単純なマッチング

正規表現が文字列にマッチすれば真を、そうでなければ偽を返す。

```perl
perl) if($str =~ /[A-Z][0-9]+/){ ... }
```
```julia
julia) if ismatch(r"/[A-Z][0-9]+/",str ... end
```

#### 置換

以下に単純な置換の例を示す。

```perl
perl) $str = s/[XYZ]/_/g
```
```julia
julia) str = replace(str,r"[XYZ]","_")
```

Juliaでは、 Perlと同様に、マッチした部分を置換パターンに再利用することができる。
まず、正規表現の中でのちに参照したい部分を `()` でくくる。 次に、置換パターンを `s""` で定義し、最初にマッチしたパターンを `\1`、2番目にマッチしたパターンを `\2` などとして参照する。

```perl
perl) $str = s/[XYZ]/_/g
```
```julia
julia) str = replace(str,r"([A-Z][A-Z][A-Z])(.)([0-9]*)",s"\1\3\2")
```

Juliaでは、Pythonスタイルの参照方法を利用することもできる（Perlにも逆輸入され、利用できるようになっているはずである）。
この場合、正規表現内でのちほど参照したい部分を `(?)` でくくり、その中に適当なラベルを `<>` で指定する。 
次に、置換パターンを `s""` で定義し、その中で前述のラベルを `\g<>` で参照する。 
前述のように `\1` のような表記とも混在できる。
上の例を別のスタイルで書き直す。

```julia
julia) str = replace("XYZF0123456789",
             r"(?<code>[A-Z][A-Z][A-Z])(?<category>.)(?<number>[0-9]*)",
             s"\g<code>\g<number>\g<category>")
```

ファイル
--------

ここではテキストファイルの単純な読み書きのみを扱う。

### ファイルの読み込み

両言語でよく利用されるファイル処理関数を比較する（ごく一部の機能のみを示す）。

| |Perl|Julia|
|:---|:---|:----|
|ファイルのオープン|`open(ハンドル,ファイル名＋モード)`|`ハンドル = open(ファイル名,モード文字列)`|
|ファイルのクローズ|`close(ハンドル)`|`close(ハンドル)`|
|ファイル末端のチェック|`eof(ハンドル)`|`eof(ハンドル)`|
|1行読み込み|`<ハンドル>`（改行文字を含む）|`readline(ハンドル)`（改行文字を含まない）|
|1行書き込み|`print ハンドル 出力内容`（改行文字を含まない）|`write(ハンドル,出力内容)`（改行文字を含まない）|
|末尾の改行文字の除去|`chomp(文字列)`|`chomp(文字列)`|

まずは両方の言語で同等の処理を示す。

```perl
perl) open(FILE,"<file.txt") or die;
perl) while($line=<FILE>){
         chomp($line);
         print $line,"\n";
      }
      close(FILE);
```
```julia
julia) fp = open("file.txt","r")
julia) while !eof(fp)
          line = readline(fp)
          println(line)
       end
       close(fp);
```

Juliaの`open()` 関数はC言語のものに似ており、ファイルが存在しないなどオープンの問題がある場合にはエラーで停止する。
Juliaの `readline()` 関数は、改行文字を含まない。
そのため、`chomp()` で改行文字を切り落とす必要がない。

Juliaでのファイル読み込みでは、以下のように `do ... end` を用いた構文がよく用いられる（この部分が無名関数として`open`に渡されている）。
この場合、`close()` を入力する必要がない。

```julia
julia) open("file.txt","r") do fp
          while !eof(fp)
             line = readline(fp)
             println(line)
          end
       end
```

### ファイルの書き込み

典型的なファイルの書き出し処理を、両言語で示す。

```perl
perl) open(FILE,">file.txt") or die;
perl) foreach $line (@data){
         print FILE $line,"\n";
      }
      close(FILE);
```
```julia
julia) open("file.txt","w") do fp
          for line in data
             write(fp,line,"\n")
          end
       end
```


サブルーチン
----------

### サブルーチン（関数）の定義

両言語でのサブルーチン（Juliaでは関数）の定義しかたの違いを列挙する。

| |Perl|Julia|
|:---|:---|:----|
|定義|`sub 名前 { ... }`|`function 名前(引数リスト)... end`|
|引数の参照|`@_` および `$_[0]`など|引数リストに列挙|
|引数の渡し方（デフォルト）|値渡し|変数の種類による|
|引数の変更|リファレンスの場合のみ可|変数の種類による|
|複数の戻り値|不可|可|
|値の戻し方|`return` もしくは最後の文の結果|`return` もしくは最後の文の結果|

以下のサブルーチン（関数）は、2つの文字列を受け取り、それを結合した上で、アルファベットを除去した文字列を返す。

```perl
perl) sub myfunc{
         ($s1,$s2) = @_;
         my $newstr = $s1 . $s2;
         $newstr =!~ s/[a-zA-Z]//g;
         return $newstr;
      }
```
```julia
julia) function myfunc(s1::String,s2::String)
          newstr = s1 * s2
          newstr = replace(newstr,r"[a-zA-Z]","")
          return newstr
       end
```

Juliaでは明示的に引数の型を指定できるが、周囲の情報から型が確実に類推できる場合は、型を明記する必要がない。
また、関数内で新たに定義した変数は、その関数内でのみ有効なローカル変数である（スコープ）。

Juliaで複数の戻り値を使う例を以下に示す。

```julia
julia) # 和と差を返す
jilia) function plusminus(x,y)
          return x+y, x-y
       end

julia) # 2つの戻り値を受け取る
julia) p,m = plusminus(x,y)
```

#### 値渡しと参照渡し

Perlの関数の引数は、デフォルトで値渡しである。
つまり関数内でその値を変更することができない（変更できたように見えても、関数を抜けると変更が反映されない）。
Perlで引数の値を上書きするには、リファレンスを使う必要がある。

Juliaの場合、関数の引数の扱いは、型に依存する。
引数がスカラ（イミュータブル）であれば、これは無条件で値渡しになり、値の変更が不可能である。
引数が配列や辞書など（ミュータブル）ならば、これは参照渡しになり、関数内で値を変更できる。

以下の例は、引数としてスカラと配列を渡し、サブルーチン（関数）内で両方を変更しようとするものである。

```perl
perl) # 第1引数のスカラを0に、第2引数の配列の最初の要素を0にする
perl) sub update {
         my ($x,$y) = @_;
         $$x = 0
         @$y[0] = 0
      }
perl) # リファレンスで渡せば引数を上書きできる
perl) $x=10; @y=(1,2,3);
perl) update(\$x,\@y)
```
```julia
julia) # 上と同様の試み
julia) function update!(x::Int,y::Vector{Int})
          x = 0
          y[1] = 0
       end
       # xは変更できないが yは変更できる
       x=10; y=[1,2,3]
       update!(x,y)
```

Juliaに不慣れなうちは、以下のように関数を設計すると、予期せぬ挙動を避けることができる。

- 基本的には、引数を変更せず、すべての変更は `return` で返す。呼び出し元で変数を上書きする。
- 引数の配列や辞書を上書きするほうが効果的な場合は、慣例として関数名の末尾に `!` を付加する。
- 引数のスカラと配列の両方を同時に変更することを（可能な限り）避ける。スカラが `return` で返されながら、引数の配列が更新される挙動はわかりにくいためである（やむを得ない場合はドキュメントに明記する）。

モジュール
--------

両方の言語とも、サブルーチンをひとまとめにしたモジュール（パッケージ）が利用できる。

| |Perl|Julia|
|:---|:---|:----|
|パッケージの読み込み|`use モジュール名`|`using パッケージ名`|

Perlのモジュールはコマンドラインからインストールする方法が主流だが、Juliaのパッケージはプログラム内でインストールする。
以下の例は、Juliaで `PkgDev` モジュールをインストールするものである。

```julia
julia) Pkg.add("PkgDev")
```
