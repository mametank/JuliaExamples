PerlとJuliaの比較
================

PerlからJuliaに移行する場合の留意点を簡単にまとめる。

プログラム全般
------------

### スクリプトファイル

- Perlは拡張子として `.pl` を、Juliaは拡張子として `.jl` を使用する。
- どちらの言語も、コメントに `#` が利用できる。
- Juliaでは、スクリプトファイルはUnicodeで記述することが前提である。
- コマンドラインからスクリプトを実行するには、Perlなら `perl script.pl` であり、Juliaなら `julia script.jl` となる。

### プログラム

- Perlは文の末尾にセミコロンが必要である。Juliaは不要であるが、1行に複数のコマンドを並べる場合には必要である。なお、これ以降のPerlのプログラム例では、とくに必要な場合を除いてセミコロンをつけていない。
- Perlの `use strict` に相当する仕組みが、Julia（v0.6）には存在しない。
- Perlの変数には型がないが、Juliaの変数には型が存在し、これを生かすかどうかがパフォーマンスを左右する。詳しくは後述する。
- 変数のスコープは、両言語でほぼ同じである。Perlでは `{...}` が、Juliaでは `ブロック開始キーワード ... end` がスコープ範囲である。ただしJuliaでは `if ... end` と `begin ... end` ブロックは、変数のスコープとしては機能しない。
- Juliaでは関数外の処理は、動作はするが、最適化がなされないために遅い。パフォーマンスを高めるためには、すべての処理を関数に含めることが推奨される。つまり、メイン処理のための関数を作る必要がある。

制御構文
--------

### 条件文

|処理|Perl|Julia|
|:---|:---|:----|
|回数指定ループ|`if(条件){ ... } elsif(条件){ ... } else{ ... }`|`if 条件 ... elseif 条件 ... else ... end`|

どちらも改行なしで書くことができる。

```perl
perl> if($a<10){
         ...
      }
      elsif($a>20){
         ...
      }
      else{
         ...
      }
```
```julia
julia> if a<10
          ...
       elseif a>20
          ...
       else
          ...
       end
```

### 回数指定のループ

|処理|Perl|Julia|
|:---|:---|:----|
|回数指定ループ|`for(初期化;条件;カウントアップ){ ... }`|`for 範囲指定 ... end`|

どちらも改行なしで書くことができる。

```perl
# 10回のループ
perl> for($i=0;i<10;i++){
         ...
      }
```
```julia
# 10回のループ
julia> for i=1:10
         ...
       end
```

### 繰り返し処理

どちらの言語でも、配列の要素やハッシュキーの取り出しなどの繰り返し処理ができる。

|処理|Perl|Julia|
|:---|:---|:----|
|反復処理|`foreach 変数 (集合){ ... }`|`for 変数 in 集合 ... end`|

どちらも改行なしで書くことができる。

```perl
perl> foreach i (@array){
         ...
      }
```
```julia
julia> for i in array
         ...
       end
```

### 条件付き反復

|処理|Perl|Julia|
|:---|:---|:----|
|条件付き反復|`while(条件){ ... }`|`while 条件 ... end`|

どちらも改行なしで書くことができる。

```perl
perl> while($i>0){
         ...
      }
```
```julia
julia> while i>0
         ...
       end
```

### ループ制御

|処理|Perl|Julia|
|:---|:---|:----|
|ループの脱出|`last`|`break`|
|現在の処理をスキップ|`next`|`continue`|


スカラと型
---------

### スカラと型

スカラ（scalar）は単一の数量・データである。
両方の言語で、整数、浮動小数点数、文字列などはスカラとして扱われる。
ただし、Perlは型の概念が曖昧（もしくは無い）のに対し、Juliaには厳密な型の概念がある。

たとえば、Perlでは数値は整数と浮動小数点数の区別はないが、Juliaは両者を区別する。
また、Perlは文脈に応じて文字列を数値として解釈する（その逆もある）が、Juliaは指示しない限り型変換が行われることはない（文字列を数値として扱うとエラーになる）。

リテラル（ソースコードに記入する生のデータ）は、両言語でほぼ同じである。
いかに例を示す。

|処理|Perl|Julia|
|:---|:---|:----|
|整数|`10`, `123`, `1_000_000`（百万）|`10`,`123`,`1_000_000`（百万）|
|浮動小数点数|`1.0`,`3.14`,`1e-3`|`1.0`,`3.14`,`1e-3`|
|文字列|"abc"|"abc"|

### 型変換

Perlには型の概念がない。
Juliaで型変換するには、関数を使う必要がある。
型変換に関しては、以下の変数の項目でより詳しく説明する。

```julia
julia> # 数値を文字列に変換
julia> string(10)

julia> # 文字列を整数に変換
julia> parse(Int,"12345")
julia> # 文字列を浮動小数点数に変換
julia> parse(Float64,"12345")
```

データ構造と変数
-------------

### 変数名

PerlもJuliaも宣言なしで変数を利用できる。
どちらの言語にも大文字と小文字の区別がある。
Perlでは変数名に接頭辞（たとえば `$`）をつける必要があるが、Juliaでは必要ない。

```perl
perl> $a = 10
```
```julia
julia> a = 10
```

### スコープ

PerlもJuliaも、スコープ内で定義された変数は、そのスコープ内でのみ有効である。
Perlは `{ ... }` で囲まれた範囲が、Juliaはブロック（`for ... end` や `do ... end` など）がスコープとなる。
ただしJuliaでは `if ... end` と `begin ... end` ブロックは、変数のスコープとしては機能しない（つまり、この2つに関しては、ブロック内で宣言された変数が、ブロック外でも参照可能になる）。

また、Juliaでは `global` によりグローバル変数が定義できるが、推奨されていない。

### スカラ変数

#### 変数と型

Perlではスカラ変数には接頭辞 `$` を付加する（`$変数名`）が、Juliaには接頭辞は必要ない。
Perlは、スカラ変数には整数、浮動小数点数、文字列などを区別することなく代入できる。
Juliaにも、どんな値も保持できる万能型（Any）が存在するが、速度の問題から、これは推奨されていない。

Juliaでは変数に型があり、変数がその型のデータのみを扱うときに限り、非常に高速に動作する。
代表的なスカラ型として、整数（`Int`）、浮動小数点数（たとえば`Float64`）、文字列（`String`）がある。
とくに宣言が無い場合、その変数が最初に作られるときに、変数の型が確定する。
Juliaは、変数の作成と代入の手順を追うことで、たとえ型の宣言がなくても、変数型を正確に推定できる。

#### 型変換

Perlでも明示的に型を変換することはできる。
Juliaには型変換を行う関数が用意されている。

|処理|Perl|Julia|
|:---|:---|:----|
|数値を文字列に変換|`$x.""` または `"$x"`|`string(x)`|
|文字列を数値に変換|`$x+0`|`parse(型,x)`|

文字列から数値への変換には、型の指定が必須である。
以下の例を参照のこと。

```julia
julia> # 文字列を整数に変換
julia> parse(Int,x)

julia> # 文字列を浮動小数点数に変換
julia> parse(Float64,x)
```

数値から文字列への変換には、このほかにも多くの方法がある。
詳しくは後述の文字列の項目で紹介する。

### 配列

Perlでは変数名の接頭辞として `@` を使うが、Juliaでは接頭辞は必要ない。
Juliaでは、配列の要素にも型があるため、最初に定義した型以外のデータを使うことのないように配慮すべきである。

#### 配列の作成

以下の例を参照のこと。

```perl
perl> @a = (1,2,3,4,5)
```
```julia
julia> a = [1,2,3,4,5]
```

#### 配列の参照

| |Perl|Julia|
|:---|:---|:----|
|要素の参照|`$変数名[]`|`変数名[]`|
|添え字の開始位置|`0`|`1`|
|添え字の最終位置|`-1`または`$#変数名`|`end`|

```perl
perl> # 3 は 4 番目の要素
parl> $a[3]
```
```julia
julia> # 3 は 3 番目の要素
julia> a[3]
```

最後の要素を参照するには、Perlでは`-1`または`$#配列名`を、Juliaでは`end`を用いる。

```perl
perl> 最後の要素
parl> $a[-1]
perl> $a[$#a]
```
```julia
julia> # 最後の要素
julia> a[end]
```

#### 配列への要素の代入、および配列の確保

Perlでは、配列が存在しない状況でも、任意の要素位置に代入できる。
Juliaでは、存在しない配列への要素の代入はできない。

```perl
perl> # 存在しない配列の要素に代入
parl> $x[4] = 1
```
```julia
julia> # 存在しない配列への代入はエラーになる
julia> x[4] = 1
```

Juliaで配列の添え字を使うためには、その配列の型とサイズを事前に確定される必要がある。
配列を確保するには、`Array`または`Vector`キーワードを以下のように用いる。
配列を確保した上でゼロで初期化するには、`zeros()`関数を利用するか、`[]`と反復処理を組み合わせる。

```julia
julia> # 5個の要素を持つ整数型の配列を宣言する
julia> x = Vector{Int}(5)
julia> x = Array{Int,1}(5)

julia> # 配列を確保し、ゼロで初期化する
julia> x = zeros(Int,5)
julia> x = [0 for i=1:5]
```

Juliaで文字列型の配列を初期化するには、以下のようにする。

```julia
julia> # 配列を確保するが内容は初期化しない
julia> y = Array{String,1}(5)

julia> # 配列を確保して、空文字列で初期化する
julia> y = ["" for i=1:5]
```

#### pushとpop

Juliaは、配列を全く確保していなくても、pushやunshift処理を行うことができる。

| |Perl|Julia|
|:---|:---|:----|
|末尾に要素を追加|`push @変数名,値`|`push!(変数名,値)`|
|末尾の要素を除去|`pop @変数名`|`pop!(変数名)`|
|先頭に要素を追加|`unshift @変数名,値`|`unshift!(変数名,値)`|
|先頭の要素を除去|`shift @変数名`|`shift!(変数名)`|

#### 配列の範囲の参照

Perlでは、配列の一部をスライスと呼ぶ。

| |Perl|Julia|
|:---|:---|:----|
|範囲を指定する添え字|`[開始位置..終了位置]`|`[開始位置:終了位置]`|
|配列の最後の位置|`$#配列名`|`end`|

```perl
perl> 末尾の3個の要素
perl> @a[2..4]
```
```julia
julia> 末尾の3個の要素
julia> a[3:5]
```

最後の位置をキーワードで指定する。

```perl
perl> 末尾の3個の要素
perl> @a[2..$#a]
```
```julia
julia> 末尾の3個の要素
julia> a[3:end]
```

#### 配列の配列（二次元配列）

Perlの配列は一次元であり、二次元配列を擬似的に実現するには、配列の配列を使う必要がある。
Juliaでは二次元配列が定義できるだけでなく、配列の配列も定義できる。
Juliaの二次元配列は、一次元配列とは明確に区別されている（たとえば要素の区切りにカンマではなくスペースを使用する）。

```perl
# 配列の配列で行列を実現する；2行3列目の要素を抜き出す
perl> @a = ([1,2,3],[4,5,6])
perl> $a[1][2]
```
```julia
# 行列を定義し、2行3列目の要素を抜き出す
# 要素の区切りにはスペースを使う；カンマで区切るとエラーになる
julia> a = [1 2 3; 4 5 6]
julia> a[2,3]
```

以下の例は、Juliaで配列の配列を定義するものである。

```julia
julia> a = [[1,2,3],[4,5,6]]
julia> a[2][3]
```

### ハッシュ（辞書）

#### ハッシュの作成

連想配列は、Perlではハッシュ、Juliaでは辞書と呼ばれる。
PerlもJuliaも、キーと値の両方にどのような型を使ってもよい。
ただしJuliaでは、キーと値の型を事前に定義しておく必要がある。
Perlのハッシュ変数には接頭辞 `%` を付加するが、Juliaでは接頭辞は必要ない。

```perl
perl> # 1行目のハッシュの初期化は実際には不要
perl> %hash = ()
perl> $hash{"abc"} = 1
```
```julia
julia> # ハッシュの初期化が必要（キーは文字列、値は整数）
julia> hash = Dict{String,Int}()
julia> hash["abc"] = 1
```

以下の例ではハッシュに配列を格納している（配列のハッシュ）。
Juliaは、配列の型を事前に決める必要がある。

```perl
perl> # 1行目のハッシュの初期化は実際には不要
perl> %hash = ()
perl> $hash{"abc"} = ([1,2,3])
```
```julia
julia> # ハッシュの初期化が必要（キーは文字列、値は整数）
julia> hash = Dict{String,Vector{Int}}()
julia> hash["abc"] = [1,2,3]
```

#### キーと値の取り出し

ハッシュ内に存在しないキーを指定した場合、Perlでは暗黙の空白（数値ではゼロ）を返すが、Juliaではエラーになる。
そのため、Juliaでは、キーに対応したエントリが存在するかどうかを確認する必要がある。
また、どちらの言語にも、キーと値を取り出す関数がある。

| |Perl|Julia|
|:---|:---|:----|
|要素の存在を確認|`exists 要素`|`haskey(辞書,キー)`|
|キーの集合を抜き出す|`keys ハッシュ`|`keys(辞書)`|
|値の集合を抜き出す|`values ハッシュ`|`values(辞書)`|
|キーと値のペアを抜き出す|`each`|以下の例を参照|

エントリの存在を確認するプログラム例を示す。

```perl
perl> if(exists $hash{"abc"}){ ... }
```
```julia
julia> if haskey(hash,"abc") ... end
```

以下の例は、存在するキーを取り出して順次処理する典型的なプログラムである。

```perl
perl> foreach $key (keys %hash){
         ...
      }
```
```julia
julia> for key in keys(hash)
          ...
       end
```

以下の例は、キーと値のペアを順次取り出すプログラムである。

```perl
perl> while (($key,$value) = each %hash){
         ...
      }
```
```julia
julia> for (key,value) in hash
          ...
       end
```

#### エントリの削除とハッシュの初期化

| |Perl|Julia|
|:---|:---|:----|
|エントリの削除|`delete 要素`|`delete(辞書名,キー)`|
|ハッシュの初期化|`%変数=()`|`変数=Dict{キー型,値型}()`|


リファレンス
----------

Juliaには、いくつか不思議に見える挙動がある。
これは、配列を参照する変数（以下の例）で顕著である。

```julia
julia> a = [1,2,3]  # 配列を作る
julia> b = a        # bはaを参照する
julia> b[1] = 0     # bを変更する
julia> println(a)   # 元の配列を表示
[0, 2, 3]           # bを変更すると、aも変更された！
```

これは数値では起こらない。
たとえば `a=10; b=a; b=0` としても、`a`は10のままである。
これは、Juliaでは、数値はイミュータブル（変更不可）で値渡し、配列や辞書はミュータブル（変更可能）で参照渡しであることに由来する。

つまり、Juliaでは、ある変数が配列や辞書（ミュータブル）である場合、それを参照する変数はリファレンス（ポインタ）であって、元のデータのコピーを持つわけではない。
もし、リファレンスではなく、元の実体のコピーを作りたいなら、`copy()` 関数を用いる。

```julia
julia> a = [1,2,3]  # 配列を作る
julia> b = copy(a)  # bはaのコピーを持つ
julia> b[1] = 0     # bを変更する
julia> println(a)   # 元の配列を表示
[1, 2, 3]           # aとbは別物なので、値は変更されていない
```

この挙動は、サブルーチン（関数）の設計に影響する。

正規表現
--------

Juliaは、Perl相当の正規表現を処理でき、検索と置換に関する関数が用意されている。
Perlの正規表現はそれ単体のオブジェクトだが、Juliaでは特殊な文字列 `r"正規表現"` を用いて指定する（文字列に `r` がついている）。
PerlとJuliaの機能は、以下のように対応できる。

| |Perl|Julia|
|:---|:---|:----|
|マッチング|`文字列 =~ /正規表現/`|`ismatch(正規表現,文字列)`|
|置換|`検索文字列 =~ s/検索パターン/置換パターン/g`|`replace(検索文字列,検索パターン,置換パターン)`|

### 単純なマッチング

正規表現が文字列にマッチすれば真を、そうでなければ偽を返す。

```perl
perl> if($str =~ /[A-Z][0-9]+/){ ... }
```
```julia
julia> if ismatch(r"/[A-Z][0-9]+/",str ... end
```

### 置換

以下に単純な置換の例を示す。

```perl
perl> $str = s/[XYZ]/_/g
```
```julia
julia> str = replace(str,r"[XYZ]","_")
```

Juliaでは、 Perlと同様に、マッチした部分を置換パターンに再利用することができる。
まず、正規表現の中でのちに参照したい部分を `()` でくくる。 次に、置換パターンを `s""` で定義し、最初にマッチしたパターンを `\1`、2番目にマッチしたパターンを `\2` などとして参照する。

```perl
perl> $str = s/[XYZ]/_/g
```
```julia
julia> str = replace(str,r"([A-Z][A-Z][A-Z])(.)([0-9]*)",s"\1\3\2")
```

Juliaでは、Pythonスタイルの参照方法を利用することもできる（Perlにも逆輸入され、利用できるようになっているはずである）。
この場合、正規表現内でのちほど参照したい部分を `(?)` でくくり、その中に適当なラベルを `<>` で指定する。 
次に、置換パターンを `s""` で定義し、その中で前述のラベルを `\g<>` で参照する。 
前述のように `\1` のような表記とも混在できる。
上の例を別のスタイルで書き直す。

```julia
julia> str = replace("XYZF0123456789",
             r"(?<code>[A-Z][A-Z][A-Z])(?<category>.)(?<number>[0-9]*)",
             s"\g<code>\g<number>\g<category>")
```
